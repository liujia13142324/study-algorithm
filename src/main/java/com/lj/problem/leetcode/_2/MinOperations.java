package com.lj.problem.leetcode._2;

import org.junit.Test;

/**
 * 1658. 将 x 减到 0 的最小操作数
 * 给你一个整数数组 nums 和一个整数 x 。每一次操作时，你应当移除数组 nums 最左边或最右边的元素，然后从 x 中减去该元素的值。请注意，需要 修改 数组以供接下来的操作使用。
 * 如果可以将 x 恰好 减到 0 ，返回 最小操作数 ；否则，返回 -1 。
 *
 * 示例 1：
 * 输入：nums = [1,1,4,2,3], x = 5
 * 输出：2
 * 解释：最佳解决方案是移除后两个元素，将 x 减到 0 。

 * 示例 2：
 * 输入：nums = [5,6,7,8,9], x = 4
 * 输出：-1

 * 示例 3：
 * 输入：nums = [3,2,20,1,1,3], x = 10
 * 输出：5
 * 解释：最佳解决方案是移除后三个元素和前两个元素（总共 5 次操作），将 x 减到 0 。
 *
 *
 * 提示：
 * 1 <= nums.length <= 105
 * 1 <= nums[i] <= 104
 * 1 <= x <= 109
 */
public class MinOperations {

    @Test
    public void test() {
        System.out.println(minOperations(new int[]{1,1,4,2,3}, 5));
        System.out.println(minOperations(new int[]{5,6,7,8,9}, 4));
        System.out.println(minOperations(new int[]{3,2,20,1,1,3}, 10));
        System.out.println(minOperations(new int[]{8828,9581,49,9818,9974,9869,9991,10000,10000,10000,9999,9993,9904,8819,1231,6309}, 134365));
        System.out.println(minOperations(new int[]{
                1241,8769,9151,3211,2314,8007,3713,5835,2176,8227,5251,9229,904,1899,5513,7878,8663,3804,2685,3501,1204,9742,2578,8849,1120,4687,5902,9929,6769,8171,5150,1343,9619,3973,3273,6427,47,8701,2741,7402,1412,2223,8152,805,6726,9128,2794,7137,6725,4279,7200,5582,9583,7443,6573,7221,1423,4859,2608,3772,7437,2581,975,3893,9172,3,3113,2978,9300,6029,4958,229,4630,653,1421,5512,5392,7287,8643,4495,2640,8047,7268,3878,6010,8070,7560,8931,76,6502,5952,4871,5986,4935,3015,8263,7497,8153,384,1136
        }, 894887480));
        System.out.println(minOperations(new int[]{
                5207,5594,477,6938,8010,7606,2356,6349,3970,751,5997,6114,9903,3859,6900,7722,2378,1996,8902,228,4461,90,7321,7893,4879,9987,1146,8177,1073,7254,5088,402,4266,6443,3084,1403,5357,2565,3470,3639,9468,8932,3119,5839,8008,2712,2735,825,4236,3703,2711,530,9630,1521,2174,5027,4833,3483,445,8300,3194,8784,279,3097,1491,9864,4992,6164,2043,5364,9192,9649,9944,7230,7224,585,3722,5628,4833,8379,3967,5649,2554,5828,4331,3547,7847,5433,3394,4968,9983,3540,9224,6216,9665,8070,31,3555,4198,2626,9553,9724,4503,1951,9980,3975,6025,8928,2952,911,3674,6620,3745,6548,4985,5206,5777,1908,6029,2322,2626,2188,5639
        }, 565610));

        System.out.println(minOperations2(new int[]{1,1,4,2,3}, 5));
        System.out.println(minOperations2(new int[]{5,6,7,8,9}, 4));
        System.out.println(minOperations2(new int[]{3,2,20,1,1,3}, 10));
        System.out.println(minOperations2(new int[]{8828,9581,49,9818,9974,9869,9991,10000,10000,10000,9999,9993,9904,8819,1231,6309}, 134365));
        System.out.println(minOperations2(new int[]{
                1241,8769,9151,3211,2314,8007,3713,5835,2176,8227,5251,9229,904,1899,5513,7878,8663,3804,2685,3501,1204,9742,2578,8849,1120,4687,5902,9929,6769,8171,5150,1343,9619,3973,3273,6427,47,8701,2741,7402,1412,2223,8152,805,6726,9128,2794,7137,6725,4279,7200,5582,9583,7443,6573,7221,1423,4859,2608,3772,7437,2581,975,3893,9172,3,3113,2978,9300,6029,4958,229,4630,653,1421,5512,5392,7287,8643,4495,2640,8047,7268,3878,6010,8070,7560,8931,76,6502,5952,4871,5986,4935,3015,8263,7497,8153,384,1136
        }, 894887480));
        System.out.println(minOperations2(new int[]{
                5207,5594,477,6938,8010,7606,2356,6349,3970,751,5997,6114,9903,3859,6900,7722,2378,1996,8902,228,4461,90,7321,7893,4879,9987,1146,8177,1073,7254,5088,402,4266,6443,3084,1403,5357,2565,3470,3639,9468,8932,3119,5839,8008,2712,2735,825,4236,3703,2711,530,9630,1521,2174,5027,4833,3483,445,8300,3194,8784,279,3097,1491,9864,4992,6164,2043,5364,9192,9649,9944,7230,7224,585,3722,5628,4833,8379,3967,5649,2554,5828,4331,3547,7847,5433,3394,4968,9983,3540,9224,6216,9665,8070,31,3555,4198,2626,9553,9724,4503,1951,9980,3975,6025,8928,2952,911,3674,6620,3745,6548,4985,5206,5777,1908,6029,2322,2626,2188,5639
        }, 565610));
    }


    /**
     * 逆向思维：剔除最左右的最短结果，剩下的就是一个连续子数组，令它的和记作 sumRemains
     * sumTotal = x + sumRemains
     * sumRemains = sumTotal - x
     * 转换成求 sumRemains 的最长子数组
     */
    public int minOperations2(int[] nums, int x) {
        int sumTotal = 0;
        for (int num: nums) {
            sumTotal += num;
        }
        if (sumTotal < x) {
            return -1;
        }
        int sumRemain = sumTotal - x;
        int sum = 0, l = 0, ans = Integer.MIN_VALUE;
        for (int r = 0; r < nums.length; r++) {
            sum += nums[r];
            while (sum > sumRemain) {
                sum -= nums[l++];
            }
            if (sum == sumRemain) {
                ans = Math.max(ans, r - l + 1);
            }
        }

        return ans == Integer.MIN_VALUE ? -1 : nums.length - ans;
    }


    /**
     * 正向，直接双指针，麻烦一些，先算左窗口，然后向右移动
     * @param nums
     * @param x
     * @return
     */
    public int minOperations(int[] nums, int x) {

        int l = 0, ans = Integer.MAX_VALUE, sum = 0;

        for (; l < nums.length && sum + nums[l] < x; l++) {
            sum += nums[l];
        }
        // 此时 l >= nums.length 或者 sum + nums[l] >= x
        if (l >= nums.length) {
            // sum 比 x 还小，直接返回
            return -1;
        }

        if (sum + nums[l] == x) {
            // 这个优化，不要随便加吧...，nums[i] 如果可以等于0，情况会比较麻烦
//            if (l == nums.length - 1) {
//                return l + 1;
//            }
            sum = x;
            ans = l + 1;
        }else {
            l--;
        }

        for (int r = nums.length - 1; l >= 0 || sum < x; r--) {
            sum += nums[r];
            while (l >= 0 && sum > x) {
                sum -= nums[l--];
            }
            if (sum == x) {
                ans = Math.min(ans, l + 1 + nums.length - r);
            }
        }

//        int r = nums.length - 1;
//        while (l >= 0 || sum < x) {
//            sum += nums[r];
//            while (l >= 0 && sum > x) {
//                sum -= nums[l--];
//            }
//            if (sum == x) {
//                ans = Math.min(ans, l + 1 + nums.length - r);
//            }
//            r--;
//        }

        return ans == Integer.MAX_VALUE ? -1 : ans;
    }

}
